# 버블 정렬
> 오름차순 정렬을 위한 버블 정렬이라 가정

## 버블 정렬이란?
* 서로 인접한 두 원소를 검사하여 정렬하는 알고리즘
    - 인접한 2개의 원소를 비교하여 크기가 순서대로 되어 있지 않으면 서로 교환한다.
* 정렬을 1회전 수행할 때마다 정렬에서 제외되는 데이터가 하나씩 늘어난다.

## 버블 정렬 구현 - 자바스크립트
```js
const swap = (targetArray, currentIndex, cur, next) => {
    targetArray[currentIndex] = next;
    targetArray[currentIndex+1] = cur;
};

const bubbleSorting = (numbers) => {
    const newNumbers = numbers.slice();
    const length = numbers.length;
    let isSwap = false;
    
    for (let i = length - 1; i > 0; i--) {
        for (let j = 0; j < i; j ++) {
            let cur = newNumbers[j];
            let next = newNumbers[j + 1];

            if (cur > next) {
                isSwap = true;
                swap(newNumbers, j, cur, next,);
            }
        }
        if (!isSwap) return newNumbers; // 원소 간 swap이 발생하지 않은 최선의 경우
    }

    return newNumbers;
};  


// test
const numbers = [8, 4, 9, 2, 5, 10, 15, 22, 88, 63, 18];
console.log(bubbleSorting(numbers)); // [2, 4, 5, 8, 9, 10, 15, 18, 22, 63, 88]

const numbers2 = [7, 4, 5, 1];
console.log(bubbleSorting(numbers2)); // [ 1, 4, 5, 7 ]
```

## 버블 정렬 알고리즘 특징
> 일반적으로 자료의 교환 작업(SWAP)이 자료의 이동 작업(MOVE)보다 더 복잡하기 때문에 버블 정렬은 구현의 단순성에도 불구하고 거의 사용되지 않는다.
### 장점
* 구현이 매우 간단하다.
### 단점
* 하나의 요소가 가장 왼쪽에서 가장 오른쪽으로 이동하기 위해서는 배열에서 모든 요소들과 교환되어야 한다.
* 특히 특정 요소가 최종 정렬 위치에 이미 있는 경우라도 교환되는 일이 발생할 수 있다.

## 버블 정렬 시간 복잡도
### 최선의 경우; Best
* 입력 자료가 이미 정렬되어 있는 경우에는 한번의 순회로 정렬 여부를 알 수 있다.
* 요소의 이동이 발생하지 않는다. 
* `O(n)`의 시간 복잡도가 소요된다.

### 최악의 경우; Worst
* 입력 자료가 완벽히 역순으로 정렬되어 있는 경우가 최악의 경우이다.
* 비교 횟수
    - n-1, n-2 ... 2, 1번 = n(n-2)/2
* 교환 횟수
    - swap을 위한 연산은 총 3번
    - 비교 연산 후, swap을 위한 연산 3번
* 총 연산 횟수는 `3 * {n(n-2)/2}`이며, 버블 정렬의 시간복잡도는 `빅오 표기법: O(N^2)`이 된다.

